The Challenge The goal is to modify a sorted array in-place so that each unique element appears at most twice. We need to do this with O(1) extra space (no extra arrays allowed!) and return the new length of the modified portion. The "Two-Pointer" Logic Since the array is already sorted, all duplicates are naturally grouped together. The Writer (k): We use a pointer k to track the position where the next valid element should be written. We start k at 2 because the first two elements of any sorted array are always valid (even if they are the same, they don't exceed our "at most twice" limit).The Scanner (i): We iterate through the array starting from the third element (index 2).The Comparison: For every element nums[i], we check if it is different from the element sitting two positions behind our writer (nums[k-2]).If it's different, it means we haven't filled two slots with this value yet. We "write" it at index k and move the writer forward.If it's the same, we simply skip it.

Use code with caution. Complexity Analysis Time Complexity: \(O(n)\) — We traverse the array exactly once.Space Complexity: \(O(1)\) — We only use a single integer variable for tracking, regardless of the array size. 
